import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}==========================================================================================================================
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
=========================================================================================================================



import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}


=======================================================================================================
2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222
=======================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}
=============================================================================================================
333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333
==============================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}========================================================================================================================
33333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333
====================================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}





import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}==========================================================================================================================
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
=========================================================================================================================



import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}


=======================================================================================================
2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222
=======================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}
=============================================================================================================
333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333
==============================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}========================================================================================================================
33333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333
====================================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}



import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}==========================================================================================================================
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
=========================================================================================================================



import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}


=======================================================================================================
2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222
=======================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}
=============================================================================================================
333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333
==============================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}========================================================================================================================
33333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333
====================================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}


import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}==========================================================================================================================
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
=========================================================================================================================



import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}


=======================================================================================================
2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222
=======================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}
=============================================================================================================
333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333
==============================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}========================================================================================================================
33333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333
====================================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}==========================================================================================================================
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
=========================================================================================================================



import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}


=======================================================================================================
2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222
=======================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}
=============================================================================================================
333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333
==============================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}========================================================================================================================
33333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333
====================================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}==========================================================================================================================
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
=========================================================================================================================



import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}


=======================================================================================================
2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222
=======================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}
=============================================================================================================
333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333
==============================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}========================================================================================================================
33333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333
====================================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}





import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}==========================================================================================================================
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
=========================================================================================================================



import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}


=======================================================================================================
2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222
=======================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}
=============================================================================================================
333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333
==============================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}========================================================================================================================
33333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333
====================================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}



import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}==========================================================================================================================
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
=========================================================================================================================



import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}


=======================================================================================================
2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222
=======================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}
=============================================================================================================
333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333
==============================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}========================================================================================================================
33333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333
====================================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}


import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}==========================================================================================================================
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
=========================================================================================================================



import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}


=======================================================================================================
2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222
=======================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}
=============================================================================================================
333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333
==============================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}========================================================================================================================
33333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333
====================================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}==========================================================================================================================
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
=========================================================================================================================



import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}


=======================================================================================================
2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222
=======================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}
=============================================================================================================
333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333
==============================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}========================================================================================================================
33333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333
====================================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}==========================================================================================================================
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
=========================================================================================================================



import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}


=======================================================================================================
2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222
=======================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}
=============================================================================================================
333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333
==============================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}========================================================================================================================
33333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333
====================================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}





import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}==========================================================================================================================
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
=========================================================================================================================



import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}


=======================================================================================================
2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222
=======================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}
=============================================================================================================
333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333
==============================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}========================================================================================================================
33333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333
====================================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}



import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}==========================================================================================================================
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
=========================================================================================================================



import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}


=======================================================================================================
2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222
=======================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}
=============================================================================================================
333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333
==============================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}========================================================================================================================
33333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333
====================================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}


import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}==========================================================================================================================
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
=========================================================================================================================



import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}


=======================================================================================================
2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222
=======================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}
=============================================================================================================
333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333
==============================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}========================================================================================================================
33333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333
====================================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}==========================================================================================================================
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
=========================================================================================================================



import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}


=======================================================================================================
2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222
=======================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}
=============================================================================================================
333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333
==============================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}========================================================================================================================
33333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333
====================================================================================================================

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.net.Socket;
import java.util.Date;


public class MessageProcessor implements Runnable, MessageConstants 
{
	private static String ownPeerID = null;
	//need to be updated here
	public static int peerState = -1;
	
	RandomAccessFile raf;
	// constructor
	public MessageProcessor(String ownPeerID)
	{
		this.ownPeerID = ownPeerID;
	}
	
	// constructor
	public MessageProcessor()
	{
		ownPeerID = null;
	}
	
	public void pTS(String dataType, int state)
	{
		//System.out.println("Message Processor : msgType = "+ dataType + " State = "+state);
	}
	public void run()
	{
		DataMessage d;
		DataMessageWrapper dataWrapper;
		String msgType;
		String rPeerId;
		
		
		while(true)
		{
		do
		{
			Thread.currentThread();
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				
				e.printStackTrace();
			}
			dataWrapper  = peerProcess.removeFromMsgQueue();
		}while(dataWrapper == null);
		
		d = dataWrapper.getDataMsg();
		
		msgType = d.getMessageTypeString();
		rPeerId = dataWrapper.getFromPeerID();
		int state = peerProcess.remotePeerInfoHash.get(rPeerId).state;
		
		/* TODO: 
		 * Accomodate sudden arrival of UNCHOKE message, in state 5.
		 */
		
		pTS(msgType,state);
		if(msgType.equals(DATA_MSG_BITFIELD) && state == 2)
		{
			pTS("DATA_MSG_BITFIELD",state);
				sendBitField(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 3;
		}
		else if(msgType.equals(DATA_MSG_NOTINTERESTED) && state == 3)
		{
			pTS("DATA_MSG_NOTINTERESTED", state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 5;
		}
		else if(msgType.equals(DATA_MSG_INTERESTED) && state == 3)
		{
			pTS("DATA_MSG_INTERESTED",state);
			//TODO: Decide to send CHOKE or UNCHOKE message
		
			
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				pTS("SENDING CHOKE MESSAGE", state);
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 1;
				state = 6;
			}
			else
			{
				pTS("SENDING UNCHOKE",state);
				peerProcess.remotePeerInfoHash.get(rPeerId).isChoked = 0;
				sendUnChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 4 ;
			}
		}
		else if(msgType.equals(DATA_MSG_REQUEST) && state == 4)
		{
			pTS("DATA_MSG_REQUEST",state);
			sendPeice(peerProcess.peerIDToSocketMap.get(rPeerId), d);
			//TODO: Decide to send CHOKE or UNCHOKE message
			if(!peerProcess.preferedNeighbors.containsKey(rPeerId) && !peerProcess.unchokedNeighbors.containsKey(rPeerId))
			{
				
				sendChoke(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 6;
			} 
		}
		else if((msgType.equals(DATA_MSG_BITFIELD) && state == 8)
				|| (msgType == DATA_MSG_HAVE && state == 14))
		{
			System.out.println(" Deciding interested or not ....");
			//Decide if interested or not.
			if(isInterested(d,rPeerId))
			{
				System.out.println(" IS Interested ... ");
				sendInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 9;
			}	
			else
			{
				System.out.println(" Not interested ... ");
				sendNotInterested(peerProcess.peerIDToSocketMap.get(rPeerId));
				peerProcess.remotePeerInfoHash.get(rPeerId).state = 13;
			}
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 9)
		{
			pTS("DATA_MSG_CHOKE",state);
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 10;
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 9)
		{
			pTS("DATA_MSG_UNCHOKE",state);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField));
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();

		}
		else if(msgType.equals(DATA_MSG_PIECE) && state == 11)
		{
			pTS("DATA_MSG_PIECE",state);
			byte[] buffer = d.getPayload();
				
			System.out.println("payload length in message processor = " + buffer.length);
			peerProcess.remotePeerInfoHash.get(rPeerId).finishTime = new Date();
			long timeLapse = peerProcess.remotePeerInfoHash.get(rPeerId).finishTime.getTime() - 
						peerProcess.remotePeerInfoHash.get(rPeerId).startTime.getTime() ;
			peerProcess.remotePeerInfoHash.get(rPeerId).dataRate = (double)(buffer.length)/(double)timeLapse;
	
			
			peerProcess.ownBitField.updateBitField(ownPeerID, Piece.decodePiece(buffer));
			int toGetPeiceIndex = peerProcess.ownBitField.returnFirstDiff(peerProcess.remotePeerInfoHash.get(rPeerId).bitField);
			sendRequest(peerProcess.peerIDToSocketMap.get(rPeerId),toGetPeiceIndex);
			state = 11;
			// Get the time when the request is being sent.
			peerProcess.remotePeerInfoHash.get(rPeerId).startTime = new Date();
			
			buffer = null;
			d = null;
		}
		else if(msgType.equals(DATA_MSG_CHOKE) && state == 11)
		{
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
			
		}
		else if(msgType.equals(DATA_MSG_UNCHOKE) && state == 14)
		{
			//TODO: Fix this -- it is an error.
			peerProcess.remotePeerInfoHash.get(rPeerId).state = 14;
		}	
		}
	}


	private void sendRequest(Socket socket, int peiceNo) {
		
		// Byte2int....
		byte []pieceByte = new byte[MessageConstants.PIECE_INDEX_LEN];
		for(int i=0;i<MessageConstants.PIECE_INDEX_LEN;i++)
		{
			pieceByte[i]=0;
		}
		
		byte []pieceIndexByte = ConversionUtil.intToByteArray(peiceNo);
		System.arraycopy(pieceIndexByte, 0, pieceByte, 0, pieceIndexByte.length);
		DataMessage d = new DataMessage(DATA_MSG_REQUEST, pieceByte);
		byte[] b = DataMessage.encodeMessage(d);
		SendData(socket,b);
		
		pieceByte = null;
		pieceIndexByte = null;
		b = null;
		d = null;
	}

	private void sendPeice(Socket socket, DataMessage d)  //d == requestmessage
	{
		byte[] bytePieceIndex = d.getPayload();
		
		//if(bytePieceIndex.length != 4) System.out.println(" data Payload in Request message not 4 bytes");		//TODO: call buteToInt()
		//System.out.println("peice index size = " + bytePieceIndex.length);
		int pieceIndex = ConversionUtil.byteArrayToInt(bytePieceIndex);
		
		byte[] byteRead = new byte[CommonProperties.pieceSize];
		int noBytesRead = 0;
		
		File file = new File(peerProcess.peerID,CommonProperties.fileName);
		try 
		{
			raf = new RandomAccessFile(file,"r");
			raf.seek(pieceIndex*CommonProperties.pieceSize);
			noBytesRead = raf.read(byteRead, 0, CommonProperties.pieceSize);
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		if( noBytesRead == 0)
		{
			System.out.print("ERROR :  Zero bytes read from the file !");
		}
		else if (noBytesRead < 0)
		{
			System.out.println(" ERROR : File could not be read properly.");
		}
		
		byte[] buffer = new byte[noBytesRead + MessageConstants.PIECE_INDEX_LEN];
		
		
		//System.out.println(" No of bytes read = " +byteRead.length);
		
		System.arraycopy(bytePieceIndex, 0, buffer, 0, MessageConstants.PIECE_INDEX_LEN);
		System.arraycopy(byteRead, 0, buffer, MessageConstants.PIECE_INDEX_LEN, noBytesRead);
		
		DataMessage sendMessage = new DataMessage(DATA_MSG_PIECE, buffer);
		
		byte[] b =  DataMessage.encodeMessage(sendMessage);
		//System.out.println("total payload = " + sendMessage.getPayload().length);
		//System.out.println("total data msg size = " + b.length);
		SendData(socket, b);
		
		//release memory
		buffer = null;
		byteRead = null;
		b = null;
		bytePieceIndex = null;
		sendMessage = null;
		
		try{
			raf.close();
		}
		catch(Exception e){}
	}
	
	private void sendNotInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_NOTINTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendInterested(Socket socket) {
		DataMessage d =  new DataMessage(DATA_MSG_INTERESTED);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
		
	}

	private boolean isInterested(DataMessage d, String rPeerId) {
		//  Compare the bitfield and send TRUE if there is any extra data
		BitField b = BitField.decode(d.getPayload());
		peerProcess.remotePeerInfoHash.get(rPeerId).bitField = b;
		
		System.out.println("bit field size " + b.size);
		if(peerProcess.ownBitField.compare(b))
			return true;
		return false;
	}

	private void sendUnChoke(Socket socket) {

		DataMessage d = new DataMessage(DATA_MSG_UNCHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendChoke(Socket socket) {
		DataMessage d = new DataMessage(DATA_MSG_CHOKE);
		byte[] msgByte = DataMessage.encodeMessage(d);
		SendData(socket,msgByte);
	}

	private void sendBitField(Socket socket) {
	
		byte[] encodedBitField = peerProcess.ownBitField.encode();
		DataMessage d = new DataMessage(DATA_MSG_BITFIELD, encodedBitField);
		SendData(socket,DataMessage.encodeMessage(d));
		
		encodedBitField = null;
	}

	private int SendData(Socket socket, byte[] encodedBitField) {
		try {
		OutputStream out = socket.getOutputStream();
		out.write(encodedBitField);
		} catch (IOException e) {
			
			e.printStackTrace();
			return 0;
		}
		return 1;
	}

}THE END
